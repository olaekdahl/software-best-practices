#!/usr/bin/env python3
"""
Generate simple Mermaid diagrams for a Python module (default: app.py).

Outputs:
- diagrams/generated/app_structure.mmd (Mermaid class diagram)
- diagrams/generated/app_structure.md (Markdown with Mermaid diagrams)

If Flask-style routes are detected (decorators like @app.route("/path", methods=[...])),
an additional Mermaid flowchart is embedded in the Markdown output to show endpoints.
"""

from __future__ import annotations

import ast
import os
import textwrap
from typing import List, Dict, Tuple, Optional


def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


class ModuleInfo(ast.NodeVisitor):
    def __init__(self) -> None:
        self.classes: Dict[str, Dict[str, List[str]]] = {}
        self.functions: List[str] = []
        self.routes: List[Tuple[str, str, str]] = []  # (method(s), path, handler)

    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        methods: List[str] = []
        for n in node.body:
            if isinstance(n, ast.FunctionDef):
                methods.append(n.name)
        bases = [
            getattr(b, "id", getattr(getattr(b, "attr", None), "__str__", lambda: None)())
            if isinstance(b, ast.Name)
            else (b.attr if isinstance(b, ast.Attribute) else getattr(b, "id", ""))
            for b in node.bases
        ]
        self.classes[node.name] = {"methods": methods, "bases": [b for b in bases if b]}
        self.generic_visit(node)

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        # Top-level functions only
        if isinstance(getattr(node, "parent", None), ast.Module) or not hasattr(node, "parent"):
            self.functions.append(node.name)

        # Detect Flask-style routes: @app.route("/path", methods=[...])
        for dec in node.decorator_list:
            method_str = ""
            path_str = ""
            try:
                if isinstance(dec, ast.Call) and isinstance(dec.func, ast.Attribute) and dec.func.attr == "route":
                    # First positional arg as path
                    if dec.args and isinstance(dec.args[0], ast.Str):
                        path_str = dec.args[0].s
                    # Methods keyword
                    for kw in dec.keywords:
                        if kw.arg == "methods" and isinstance(kw.value, (ast.List, ast.Tuple)):
                            methods = []
                            for elt in kw.value.elts:
                                if isinstance(elt, ast.Str):
                                    methods.append(elt.s)
                            if methods:
                                method_str = ",".join(methods)
                    if not method_str:
                        method_str = "GET"  # default guess
                    if path_str:
                        self.routes.append((method_str, path_str, node.name))
            except Exception:
                pass

        self.generic_visit(node)


def attach_parents(tree: ast.AST) -> None:
    for node in ast.walk(tree):
        for child in ast.iter_child_nodes(node):
            setattr(child, "parent", node)


def to_mermaid_class_diagram(info: ModuleInfo) -> str:
    lines: List[str] = ["%% Autogenerated by scripts/gen_mermaid.py", "classDiagram"]

    # Classes
    for cls, meta in sorted(info.classes.items(), key=lambda x: x[0].lower()):
        lines.append(f"  class {cls} {{")
        for m in sorted(meta["methods"], key=str.lower):
            lines.append(f"    +{m}()")
        lines.append("  }")
        for base in meta["bases"]:
            lines.append(f"  {base} <|-- {cls}")

    # Represent top-level functions as a pseudo class
    if info.functions:
        lines.append("  class Module { ")
        for fn in sorted(info.functions, key=str.lower):
            lines.append(f"    +{fn}()")
        lines.append("  }")

    return "\n".join(lines) + "\n"


def to_mermaid_routes_flow(info: ModuleInfo) -> Optional[str]:
    if not info.routes:
        return None
    lines: List[str] = [
        "%% Autogenerated by scripts/gen_mermaid.py",
        "flowchart LR",
        "  User([User]) -->|HTTP| API[app.py]",
    ]
    for methods, path, handler in sorted(info.routes, key=lambda x: (x[1], x[0])):
        label = f"{methods} {path}".strip()
        safe_handler = handler.replace("\"", "'")
        lines.append(f"  API -->|{label}| {safe_handler}[{safe_handler}()]")
    return "\n".join(lines) + "\n"


def main() -> None:
    source_file = os.environ.get("SOURCE_FILE", "app.py")
    out_dir = os.environ.get("OUTPUT_DIR", os.path.join("diagrams", "generated"))

    if not os.path.isfile(source_file):
        print(f"Warning: {source_file} not found. Nothing to generate.")
        return

    ensure_dir(out_dir)
    code = read_file(source_file)
    tree = ast.parse(code)
    attach_parents(tree)
    info = ModuleInfo()
    info.visit(tree)

    class_mmd = to_mermaid_class_diagram(info)
    routes_flow = to_mermaid_routes_flow(info)

    # Write .mmd (class diagram only)
    mmd_path = os.path.join(out_dir, "app_structure.mmd")
    with open(mmd_path, "w", encoding="utf-8") as f:
        f.write(class_mmd)

    # Write Markdown with both diagrams
    md_path = os.path.join(out_dir, "app_structure.md")
    with open(md_path, "w", encoding="utf-8") as f:
        f.write("# App structure diagrams (auto-generated)\n\n")
        f.write("## Class diagram\n\n")
        f.write("```mermaid\n")
        f.write(class_mmd)
        f.write("```\n\n")
        if routes_flow:
            f.write("## Routes overview\n\n")
            f.write("```mermaid\n")
            f.write(routes_flow)
            f.write("```\n")

    print(f"Generated: {mmd_path}\nGenerated: {md_path}")


if __name__ == "__main__":
    main()
